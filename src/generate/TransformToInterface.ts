import { MissingPointerError } from '@apidevtools/json-schema-ref-parser';
import type { SchemaObject } from 'ajv';
import c from 'ansi-colors';
import type { JSONSchema4 } from 'json-schema';
import { compile, Options } from 'json-schema-to-typescript';
import type IOptions from '../models/IOptions.js';
import FormatAndSave from '../services/FormatAndSave.js';

export default async function TransformToInterface(
	options: IOptions,
	jsonSchema: SchemaObject
) {
	const { typescriptPath } = options;
	if (!typescriptPath) {
		return;
	}

	const bannerComment =
		options.typescriptOptions?.bannerComment ?? defaultBannerComment;

	const maxItems = options.typescriptOptions?.maxItems ?? 10;

	const toCompile: JSONSchema4 = {
		...jsonSchema,
		...prefixNames(jsonSchema, options.prefix)
	};

	const result = await tryCompile(toCompile, { bannerComment, maxItems });

	if (!result) {
		return;
	}

	await FormatAndSave(typescriptPath, 'typescript', result);
}

type TypescriptOptions = Required<Pick<Options, 'bannerComment' | 'maxItems'>>;

async function tryCompile(
	schema: JSONSchema4,
	{ bannerComment, maxItems }: TypescriptOptions
) {
	try {
		return await compile(schema, 'ContentstackSchema', {
			additionalProperties: false,
			bannerComment,
			format: false,
			$refOptions: { mutateInputSchema: false },
			maxItems,
			strictIndexSignatures: true,
			unknownAny: true,
			unreachableDefinitions: false
		});
	} catch (ex: unknown) {
		if (ex instanceof MissingPointerError) {
			console.error(c.redBright(`âš  ${ex.message}`));
		}
	}
}

function prefixNames(
	{ definitions = {} }: JSONSchema4,
	prefix: string | undefined
): {
	readonly definitions: Record<string, JSONSchema4>;
	readonly properties: Record<string, JSONSchema4>;
} {
	if (!prefix) {
		return { definitions, properties: definitions };
	}

	const updatedDefinitions: Record<string, JSONSchema4> = {};
	const properties: Record<string, JSONSchema4> = {};

	for (const [key, value] of Object.entries(definitions)) {
		const newKey = `${prefix}${key}`;
		const updatedDefinition = updateReferencesInObject(value, prefix);
		updatedDefinitions[newKey] = updatedDefinition;
		properties[key] = updatedDefinition;
	}

	return { definitions: updatedDefinitions, properties };
}

function updateReferencesInObject(schema: object, prefix: string) {
	const result: Record<string, unknown> = {};

	for (const [key, v] of Object.entries(schema)) {
		const value = v as unknown;
		if (key === '$ref' && typeof value === 'string') {
			result[key] = updateReferenceInString(value, prefix);
			continue;
		}

		if (key === 'title' && typeof value === 'string') {
			result[key] = `${prefix}${value}`;
			continue;
		}

		if (Array.isArray(value)) {
			result[key] = updateReferencesInArray(value, prefix);
			continue;
		}

		if (typeof value === 'object' && value !== null) {
			result[key] = updateReferencesInObject(value, prefix);
			continue;
		}

		result[key] = value;
	}

	return result;
}

function updateReferencesInArray(
	value: readonly unknown[],
	prefix: string
): readonly unknown[] {
	return value.map((item) => {
		if (typeof item === 'object' && item !== null) {
			return updateReferencesInObject(item, prefix);
		}

		if (Array.isArray(item)) {
			return updateReferencesInArray(item, prefix);
		}

		return item;
	});
}

function updateReferenceInString(value: string, prefix: string) {
	const re = /^#\/definitions\/(?<name>.*)$/u;

	const match = re.exec(value);
	if (!match) {
		return value;
	}

	const { name } = match.groups as { name: string };
	return `#/definitions/${prefix}${name}`;
}

const defaultBannerComment = `/**
 * This file was automatically generated by cs-gen using
 * json-schema-to-typescript.
 *
 * DO NOT MODIFY IT BY HAND. Instead, modify the source Contentstack content
 * type models and re-run cs-gen.
 */
`;
